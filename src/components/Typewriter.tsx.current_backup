import React, { useEffect, useRef, useState } from 'react';

interface Props {
  text: string;
  speed?: number;
  delay?: number;
  className?: string;
  buggy?: boolean;
  onComplete?: () => void;
}

export const Typewriter: React.FC<Props> = ({
  text,
  speed = 50,
  delay = 0,
  className = '',
  buggy = false,
  onComplete,
}) => {
  const [displayedText, setDisplayedText] = useState('');
  const [startTyping, setStartTyping] = useState(false);

  const isFirstRender = useRef(true);

  useEffect(() => {
    setDisplayedText('');
    setStartTyping(false);

    const effectiveDelay = isFirstRender.current ? delay : 0;

    const timeout = setTimeout(() => {
      setStartTyping(true);
    }, effectiveDelay);

    isFirstRender.current = false;

    return () => clearTimeout(timeout);
  }, [text, delay]);

  useEffect(() => {
    if (!startTyping) return;

    let i = 0;
    let timeoutId: NodeJS.Timeout | null = null;
    let intervalId: NodeJS.Timeout | null = null;

    const cleanup = () => {
      if (timeoutId) clearTimeout(timeoutId);
      if (intervalId) clearInterval(intervalId);
    };

    if (buggy) {
      const type = () => {
        if (i < text.length) {
          setDisplayedText(text.slice(0, i + 1));
          i += 1;
          const randomSpeed = Math.random() * 150 + 20;
          timeoutId = setTimeout(type, randomSpeed);
        } else if (onComplete) {
          onComplete();
        }
      };
      type();
    } else {
      intervalId = setInterval(() => {
        if (i < text.length) {
          setDisplayedText(text.slice(0, i + 1));
          i += 1;
        } else {
          if (onComplete) onComplete();
          cleanup();
        }
      }, speed);
    }

    return cleanup;
  }, [startTyping, text, speed, buggy, onComplete]);

  return <span className={className}>{displayedText}</span>;
};


